---
title: Sequence
---
import MySwiper from '../../../../../../components/react/myswiper.jsx';
import Slide1 from './images/sequence-in-depth/Slide1.png';
import Slide2 from './images/sequence-in-depth/Slide2.png';
import Slide3 from './images/sequence-in-depth/Slide3.png';
import Slide4 from './images/sequence-in-depth/Slide4.png';
import Slide5 from './images/sequence-in-depth/Slide5.png';
import Slide6 from './images/sequence-in-depth/Slide6.png';
import Slide7 from './images/sequence-in-depth/Slide7.png';

export const sliderImages = [
  {
    src: Slide1.src,
    altText: "Execution starts and the program is loaded into memory.",
    tipStart: 1,
    tips: [
      "This all starts when the user runs the program.",
      "In this example, we are showing a compiled executable running. Its instructions are in a file on the disk."
    ]
  },
  {
    src: Slide2.src,
    altText: "The machine code is loaded into memory, each instruction at an identifiable address.",
    tipStart: 3,
    tips: [
      "When the program is run its instructions are loaded from disk into memory. This gives the CPU easier access to the instructions as memory is much faster to access than the disk.",
      "Every value in memory is uniquely addressable based on the computer's CPU architecture. For example, in a 64-bit machine each instruction is 64 bits long. Address 0 is the first 64 bits, address 1 is the second 64 bits, and so on."
    ]
  },
  {
    src: Slide3.src,
    altText: "The program counter has the address of the first instruction.",
    tipStart: 5,
    tips: [
      "In the CPU, the <strong>program counter</strong> is used to track the address of the current instruction.",
      "Now that we know where the first instruction is, and the CPU has this in the program counter, the next thing it will do is run that instruction, thereby starting the program."
    ]
  },
  {
    src: Slide4.src,
    altText: "Instruction 1 is loaded into the computer, and run.",
    tipStart: 7,
    tips: [
      "To run the instruction, the computer reads the memory into the CPU.",
      "The instruction is then executed within the CPU."
    ]
  },
  {
    src: Slide5.src,
    altText: "One is added to the program counter, is now 2 is the instruction.",
    tipStart: 9,
    tips: [
      "The last part of running the instruction will be to add one to the program counter.",
      "As the instructions are the same size as a single memory address, this means that the CPU is now at the next instruction."
    ]
  },
  {
    src: Slide6.src,
    altText: "Instruction 2 is loaded into the computer, and run.",
    tipStart: 11,
    tips: [
      "The process to run the next instruction remains the same: load it into the CPU, then run the instruction."
    ]
  },
  {
    src: Slide7.src,
    altText: "Instruction 2 is loaded into the computer, and run.",
    tipStart: 13,
    tips: [
      "Once this is done, the computer again adds one to the program counter.",
      "The next instruction will be the instruction at address 3.",
      "This same process runs on and on, with millions of these instructions running each second until the program is complete."
    ]
  }
];

Within a program, one of the main things you need to see is that everything runs in **sequence**.

At a low level, the computer executes each of its machine code instructions one at a time. This is central to the way the computer works and is therefore central to the way we need to think about its operation and giving it instructions of our own (**computational thinking**).

The computer's processor maintains a **program counter** that is used to keep track of the instruction the computer is currently performing. Once it finishes the current instruction, the computer adds one to the program counter, moving it to the **next instruction** in the program. Some instructions will let you control which instruction is next, but this just lets you adjust the sequence -- at its core, the computer is still performing one step and then the next.

The image below shows a visualisation of how the computer executes instructions in sequence.
Instructions flow through the CPU in order, one at a time, similar to a [data stream](../../../../part-0-getting-started/2-computer-use/1-concepts/09-streams).
Each instruction is *very* small, but the power of computing is that the CPU can execute *millions* of them each second.

![Instructions flow through the computer in sequence](./images/sequence-concept.png)

Keeping the simple idea of **sequence** in mind will be important throughout your programming journey and beyond. The computer is unintelligent and will follow the sequence of actions that you define. It will not interpret, adapt, or otherwise deviate from what you tell it to do.

## Sequence -- when, why, and how

Designing a program will require you to be able to identify a sequence of instructions that will get the computer to do what you want. This is the process of creating an **algorithm** -- a finite sequence of instructions that a computer can use to perform a task or calculate an output. When creating algorithms you have to work within the constraints of the computer. The biggest constraint is that the instructions a computer can execute are unambiguous and require no intelligence to perform.

This design process is known as **computational thinking**. You need to think about the available instructions and building blocks, and to use them creatively to come up with a sequence of instructions.

In this chapter, you will learn to create the following **building blocks**:

- [Programs](../00-program) the user can run.
- [Variables](../07-variable) to store values.

You will be able to use the following **building blocks** that others have created:

- [Methods](../02-method) that can be called to perform an action or fetch/calculate a value.
- [Libraries](../10-library) that provide you with building blocks others have created.

You will be able to instruct the computer to:

- [Call methods](../03-method-call) to run the instructions they contain.
- Store a value in a variable (called [assigning a variable a value](../08-assignment-statement)).

By putting these together you will be able to build some small programs that show visualisations and calculate values.
Once you have had practice with this, the next step in your journey will explore how we can make programs more dynamic by controlling the sequence of actions.

## Sequence Up Close

Review the following images to see how sequences are executed within the computer.

<MySwiper client:only height="" images={sliderImages}></MySwiper>

There is no magic or intelligence here. **Sequence** is simply the computer adding one to a list that is tracking where the instructions are.

*How small are these instructions?*

One line of source code will generally have several instructions.
Learning how this works is a big focus of this part of the guide.
When you read and write source code, you need to be able to think through how the instructions will run.
You don't usually need to draw the steps out as we have here, but you need to be able to visualise them in your mind.

In general, this shouldn't be too hard. Remember the following:

- Instructions run in sequence. So read through the code line by line.
- Calculated values ([expressions](../04-expression)) are evaluated before they are used. This process obeys standard mathematical rules (e.g. [BOMDAS](https://en.wiktionary.org/wiki/BOMDAS#:~:text=English-,Phrase,division%2C%20then%20addition%20and%20subtraction)).
- Study each different kind of instruction to know the steps involved in its sequence. Each kind of instruction will always have the same sequence.

With this in mind, you will be able to get started working with code that is all built upon this core concept of **sequence**.

:::tip[Slow and carefully]
Go slowly and carefully, paying attention to each piece of code. Most problems come from overthinking things or imagining powers the computer does not have. When you have an issue, slow down. Look at what the code *actually* does, not what you meant it to do. Sketch it out on paper and track the changes as things run. Most of the issues you encounter will be small things you will miss if you quickly skim over the code.
:::
