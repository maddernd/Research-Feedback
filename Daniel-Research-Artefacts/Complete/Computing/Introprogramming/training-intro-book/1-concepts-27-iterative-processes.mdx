---
title: Software Development Life Cycle
---

See how the process of building software is decomposed into smaller steps to help guide program creation.

In Software Engineering the process of building software is broken down into a number of discrete steps, commonly known as the Software Development Life Cycle (SDLC). 

This is another example of decomposition at work in how we build software. The process is complex, so to understand and control it better we break it up into a number of smaller steps which are simpler and easier to understand.

## Waterfall

In general, software engineering involves the following steps:

- **Analysis**: Understand what we need to build.
- **Design**: Come up with a plan for the artefacts we will create.
- **Implementation**: Write the code.
- **Testing**: Check it worked.

Historically, the Waterfall approach to software engineering saw each these as a sequence. First you analyse, then you design, code, and finally test. The problem with this is that building software is complex, so often you would only find issues when you are testing. These tests may identify issues in your understanding, plan, or code. The more you had produced, the harder these issues are to fix. So the Waterfall approach is generally considered how _not_ to do software development. After all, a Waterfall is all downhill.

## Iterative Development

Modern software development uses an [iterative process](https://en.wikipedia.org/wiki/Software_development_process#Agile_development) in which these four basic steps are repeated in order to work toward a solution. Rather than aiming to build a whole program in one go, we tackle the program one small part at a time.

For each iteration, you would perform the four basic steps:
- **Analysis**: Understand the part we are going to build next.
- **Design**: Come up with a plan for the artefacts we will need to get this part working.
- **Implementation**: We write the code.
- **Testing**: We check it worked.

These steps are then performed fluidly, with you moving between them as needed. For example, while you are coding up the planned design you may identify something you don't fully understand. This would require you to go back and _understand_ what needs to be done.

## Your Task

Reflect on the iterative development process. Are there parallels between this and the basic process of problem decomposition?

Let us know in the comments.