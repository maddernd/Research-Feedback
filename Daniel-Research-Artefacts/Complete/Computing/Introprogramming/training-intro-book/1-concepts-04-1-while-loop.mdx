---
title: While Loop
sidebar:
  label: " - While Loop"
---
import MySwiper from '../../../../../../components/react/myswiper.jsx'

import whileLoopSlide01 from './images/control-flow-statements-in-depth/control-flow-while-loop/Slide1.png';
import whileLoopSlide02 from './images/control-flow-statements-in-depth/control-flow-while-loop/Slide2.png';
import whileLoopSlide03 from './images/control-flow-statements-in-depth/control-flow-while-loop/Slide3.png';
import whileLoopSlide04 from './images/control-flow-statements-in-depth/control-flow-while-loop/Slide4.png';
import whileLoopSlide05 from './images/control-flow-statements-in-depth/control-flow-while-loop/Slide5.png';
import whileLoopSlide06 from './images/control-flow-statements-in-depth/control-flow-while-loop/Slide6.png';
import whileLoopSlide07 from './images/control-flow-statements-in-depth/control-flow-while-loop/Slide7.png';
import whileLoopSlide08 from './images/control-flow-statements-in-depth/control-flow-while-loop/Slide8.png';
import whileLoopSlide09 from './images/control-flow-statements-in-depth/control-flow-while-loop/Slide9.png';
import whileLoopSlide10 from './images/control-flow-statements-in-depth/control-flow-while-loop/Slide10.png';
import whileLoopSlide11 from './images/control-flow-statements-in-depth/control-flow-while-loop/Slide11.png';

import whileLoopSplashkitImg01 from './images/control-flow-statements-in-depth/slider-while-splashkit/Slide1.png';
import whileLoopSplashkitImg02 from './images/control-flow-statements-in-depth/slider-while-splashkit/Slide2.png';
import whileLoopSplashkitImg03 from './images/control-flow-statements-in-depth/slider-while-splashkit/Slide3.png';
import whileLoopSplashkitImg04 from './images/control-flow-statements-in-depth/slider-while-splashkit/Slide4.png';
import whileLoopSplashkitImg05 from './images/control-flow-statements-in-depth/slider-while-splashkit/Slide5.png';
import whileLoopSplashkitImg06 from './images/control-flow-statements-in-depth/slider-while-splashkit/Slide6.png';
import whileLoopSplashkitImg07 from './images/control-flow-statements-in-depth/slider-while-splashkit/Slide7.png';
import whileLoopSplashkitImg08 from './images/control-flow-statements-in-depth/slider-while-splashkit/Slide8.png';
import whileLoopSplashkitImg09 from './images/control-flow-statements-in-depth/slider-while-splashkit/Slide9.png';
import whileLoopSplashkitImg10 from './images/control-flow-statements-in-depth/slider-while-splashkit/Slide10.png';
import whileLoopSplashkitImg11 from './images/control-flow-statements-in-depth/slider-while-splashkit/Slide11.png';
import whileLoopSplashkitImg12 from './images/control-flow-statements-in-depth/slider-while-splashkit/Slide12.png';
import whileLoopSplashkitImg13 from './images/control-flow-statements-in-depth/slider-while-splashkit/Slide13.png';
import whileLoopSplashkitImg14 from './images/control-flow-statements-in-depth/slider-while-splashkit/Slide14.png';
import whileLoopSplashkitImg15 from './images/control-flow-statements-in-depth/slider-while-splashkit/Slide15.png';
import whileLoopSplashkitImg16 from './images/control-flow-statements-in-depth/slider-while-splashkit/Slide16.png';

export const sliderImagesWhileLoop = [
  {
    src: whileLoopSlide01.src,
    altText: "Lines 1 - 5 get the user input (in this case we'll say the user entered 10), and store it in the variable 'target' on the stack. The program counter is incremented to line 6.",
    tipStart: 1,
    tips: [
      "Lines 1 - 5 get the user input (in this case we'll say the user entered '10'), and store it in the variable 'target' on the stack.",
      "The program counter is incremented to line 6."
    ]
  },
  {
    src: whileLoopSlide02.src,
    altText: "On line 6, a variable named 'i' is declared and initialized to 0 on the stack. 'i' will function as our loop counter. The program counter is incremented to line 7, the start of our while loop.",
    tipStart: 2,
    tips: [
      "On line 6, a variable named 'i' is declared and initialized to 0.",
      "'i' will function as our loop counter.",
      "The program counter is incremented to line 7, the start of our while loop."
    ]
  },
  {
    src: whileLoopSlide03.src,
    altText: "The condition of our while loop is evaluated. Since 'i' (0) is less than 'target' (10), it evaluates to true. The program counter is incremented to the start of the while block (line 8).",
    tipStart: 3,
    tips: [
      "The condition of our while loop is evaluated. Since 'i' (0) is less than 'target' (10), it evaluates to <span class='booleanTrue'>true</span>.",
      "Because the condition is true, the program counter is incremented to the start of the while block (line 8)."
    ]
  },
  {
    src: whileLoopSlide04.src,
    altText: "The opening brace indicates the start of our while loop block of code. The program counter is incremented to line 9.",
    tipStart: 4,
    tips: [
      "The opening brace indicates the start of our while loop body.",
      "The program counter is incremented to line 9."
    ]
  },
  {
    src: whileLoopSlide05.src,
    altText: "Line 9 outputs the value of our loop counter (i) to the terminal (in this case 0). The program counter increments to line 10.",
    tipStart: 5,
    tips: [
      "Line 9 outputs the value of our loop counter 'i', which currently has a value of 0, to the terminal.",
      "The program counter increments to line 10."
    ]
  },
  {
    src: whileLoopSlide06.src,
    altText: "The value of our loop counter 'i' is incremented by 1. The program counter is incremented to line 11, where it hits the closing brace, at this point it cycles back up to line 7 in order to evaluate the while condition once more to determine if the loop is to continue or not.",
    tipStart: 6,
    tips: [
      "The value of our loop counter 'i' is incremented by 1.",
      "The program counter is incremented to line 11, where it hits the closing brace",
      "At this point the computer jumps back up to line 7 in order to evaluate the condition once more to determine if the loop is to continue or not."
    ]
  },
  {
    src: whileLoopSlide07.src,
    altText: "The while loop condition is evaluated once more. It evaluates to true because the value of 'i' (1) is still less than the value of 'target' (10), and so it will execute the block of code between the while braces once more.",
    tipStart: 7,
    tips: [
      "The while loop condition is evaluated.",
      "It evaluates to <span class='booleanTrue'>true</span> because the value of 'i' (1) is still less than the value of 'target' (10).",
      "Because the condition is true, the body of the loop will be executed again."
    ]
  },
  {
    src: whileLoopSlide08.src,
    altText: "Line 9 prints the value of 'i' (1) to the terminal. The program counter increases to line 10.",
    tipStart: 8,
    tips: [
      "Line 8 signifies the start of the looped code, so let's skip to line 9.",
      "Line 9 prints the value of 'i', which is 1, to the terminal.",
      "The program counter increases to line 10."
    ]
  },
  {
    src: whileLoopSlide09.src,
    altText: "Line 10 increments the value of 'i' by 1. The program counter moves to line 11, then back up to line 7 to evaluate the while condition to determine whether the loop continues or ends. While the loop counter 'i' is less than the value of 'target' (10), it keeps printing the value of 'i' to the terminal, then incrementing 'i'. Let's jump ahead",
    tipStart: 9,
    tips: [
      "Line 10 increments the value of 'i' by 1.",
      "The program counter moves to line 11, then back up to line 7 to evaluate the while condition to determine whether the loop continues or ends.",
      "As long as the value of the loop counter 'i' is less than the value of 'target', the computer will keep printing the value of 'i' then incrementing 'i'.",
    ]
  },
  {
    src: whileLoopSlide10.src,
    altText: "Let's jump ahead to where 'i' has just been incremented to 10. So far, the numbers 0-9 have been output to the terminal. The program counter increments to lines 11, then 7 again to evaluate the while condition.",
    tipStart: 10,
    tips: [
      "Let's jump ahead to where 'i' has just been incremented to 10.",
      "So far, the numbers 0 - 9 have been output to the terminal.",
      "The program counter increments to lines 11, then 7 again to evaluate the while condition."
    ]
  },
  {
    src: whileLoopSlide11.src,
    altText: " This time on line 7, 'i' is not less than 'target', and so evaluates to false. The program counter jumps to line 11, and both the while loop and the program end.",
    tipStart: 11,
    tips: [
      "This time at line 7, 'i' is <b>not</b> less than 'target' (10), and so the while condition evaluates to <span class='booleanFalse'>false</span>.",
      "The program counter jumps to line 11, and both the while loop and the program end."
    ]
  }
];

export const sliderImagesWhileSplashKitLoop = [
  {
    src: whileLoopSplashkitImg01.src,
    altText: "Lines 1 and 2 use the SplashKit library to open a new window on the user's desktop, with the title 'Circle Test' and the dimensions 400px x 400px",
    tipStart: 1,
    tips: [
      "Lines 1 and 2 use the SplashKit library to open a new window.",
      "The window is created in memory before opening on the user's desktop.",
      "The window has the title 'Circle Test' and dimensions 400x400px as given by the parameters to the <code>OpenWindow()</code> method."
    ]
  },
  {
    src: whileLoopSplashkitImg02.src,
    altText: "Line 3 clears the main window area, initializing it to the color yellow in memory",
    tipStart: 2,
    tips: [
      "Line 3 clears the main window area, initializing it to the color yellow.",
      "It does this in memory, so the window the user can see remains unchanged."
    ]
  },
  {
    src: whileLoopSplashkitImg03.src,
    altText: "Line 4 tests if the user has requested a quit operation, and in this case, the user hasn't so the program proceeds into the body of the while loop",
    tipStart: 3,
    tips: [
      "Line 4 contains the while loop condition.",
      "This condition tests if the user has requested a 'Quit' operation (for example by clicking the top left red quit button).",
      "In this case the user hasn't, so execution continues into the body of the while loop."
    ]
  },
  {
    src: whileLoopSplashkitImg04.src,
    altText: "At line 6 the FillCircle() function creates a new circle in the main window area (in memory only) with random dimensions",
    tipStart: 4,
    tips: [
      "At line 6, the <code>FillCircle()</code> method draws a circle on the window.",
      "It does this in memory only, not in the window created on the desktop.",
      "The parameters specify a circle with a random color, position, and radius.",
      "The max values for the circle's position are the screen width and height.",
      "The max value of the circle's radius is 50px."
    ]
  },
  {
    src: whileLoopSplashkitImg05.src,
    altText: "The call to RefreshScreen() on line 7 then updates the window on the user's desktop with the previous operations performed on the window in memory (lines 3 and 6)",
    tipStart: 5,
    tips: [
      "The call to <code>RefreshScreen()</code> on line 7 then updates the window on the user's desktop with the image stored in memory."
    ]
  },
  {
    src: whileLoopSplashkitImg06.src,
    altText: "Line 8 calls ProcessEvents() which processes any events on the event queue, including looking for user quit events",
    tipStart: 6,
    tips: [
      "Line 8 calls <code>ProcessEvents()</code>, which processes any events on the event queue (including requests from the user to quit).",
      "Execution then moves back to line 4, the start of the while loop."
    ]
  },
  {
    src: whileLoopSplashkitImg07.src,
    altText: "The while loop condition is evaluated once more. The user hasn't requested a quit, so the while loop continues",
    tipStart: 7,
    tips: [
      "The while loop condition is evaluated once more.",
      "The user hasn't requested a quit, so the condition is <span class='booleanTrue'>true</span> and the while loop executes again."
    ]
  },
  {
    src: whileLoopSplashkitImg08.src,
    altText: "Another random circle is created in the window in memory",
    tipStart: 8,
    tips: [
      "Another random circle is created in the window in memory."
    ]
  },
  {
    src: whileLoopSplashkitImg09.src,
    altText: "The window is refreshed from memory onto the desktop, displaying the new circle",
    tipStart: 9,
    tips: [
      "The window is refreshed from memory onto the desktop, displaying the new circle."
    ]
  },
  {
    src: whileLoopSplashkitImg10.src,
    altText: "Line 8 calls ProcessEvents() which processes any events on the event queue, including looking for user quit events",
    tipStart: 10,
    tips: [
      "Line 8 calls <code>ProcessEvents()</code>, which processes any events on the event queue (including requests from the user to quit).",
      "Execution then moves back to line 4, the start of the while loop."
    ]
  },
  {
    src: whileLoopSplashkitImg11.src,
    altText: "The while loop condition is evaluated once more. The user hasn't requested a quit, so the while loop continues",
    tipStart: 11,
    tips: [
      "The while loop condition is evaluated once more.",
      "The user hasn't requested a quit, so the condition is <span class='booleanTrue'>true</span> and the while loop executes again."
    ]
  },
  {
    src: whileLoopSplashkitImg12.src,
    altText: "Let's skip ahead to the 10th iteration of the loop, line 6 will update the window object in memory with the tenth circle. At this point, the user also decides to click the 'Close Window' (quit) button on the window to close it",
    tipStart: 12,
    tips: [
      "Let's skip ahead to the 10th iteration of the loop.",
      "At this point there are 9 circles visible to the user.",
      "Line 6 will update the window in memory with a tenth circle.",
      "Let's pretend that the user now decides to click the 'Close Window' (quit) button on the window to close it. This event is added to the event queue which will be processed later."
    ]
  },
  {
    src: whileLoopSplashkitImg13.src,
    altText: "The window is refreshed from memory onto the desktop, displaying the new circle",
    tipStart: 13,
    tips: [
      "The window is refreshed from memory onto the desktop, displaying the new circle."
    ]
  },
  {
    src: whileLoopSplashkitImg14.src,
    altText: "Now, the 'Close Window' event that was triggered previously, will be processed by the call to ProcessEvents(), which makes it available to our program",
    tipStart: 14,
    tips: [
      "Now, the 'Close Window' (quit) event that was triggered previously will be processed by the call to <code>ProcessEvents()</code>, which makes it available to our program."
    ]
  },
  {
    src: whileLoopSplashkitImg15.src,
    altText: "This means that when the while condition is evaluated, it will return false because the user has requested a quit. Execution moves to the end of the while loop",
    tipStart: 15,
    tips: [
      "This means that when the while condition is evaluated, it will evaluate to <span class='booleanFalse'>false</span> because the user has requested a quit.",
      "Execution moves to the end of the while loop."
    ]
  },
  {
    src: whileLoopSplashkitImg16.src,
    altText: "The loop finishes and the program ends. The window in memory will be wiped and the window on the desktop will be closed",
    tipStart: 16,
    tips: [
      "The loop finishes and the program ends.",
      "The window in memory is wiped and the window on the desktop will be closed."
    ]
  }
];

The while loop is a common feature of most programming languages. It is a pre-test loop, meaning that the statement starts with a condition, then a statement to be repeated. This means the code inside the loop will be repeated zero or more times, depending on the value of the condition. This is visualised in the following diagram.

![The pre-test Loop checks the condition, then runs the loop’s body](./images/loop-pre-test.png "The pre-test loop checks the condition, then runs the loop’s body")

## While -- when, why, and how

The while loop is a flexible way to have code repeated and will be used a lot in your programs. It should be your first thought when you want something to be repeated.

As with [branching](../03-0-branching), a while loop is a form of control flow because it literally controls the flow of instructions to the CPU.
See the image below for a visualisation of this.
Overall, the instructions are still being processed in sequence -- there are just two paths to choose from (repeating or ending the loop).

![A while loop is still seen as a sequence of instructions to the CPU](./images/pre-test-flow.png)

When planning to use a while loop, you first need to determine the condition that will indicate if the loop should be run. This condition determines if the computer continues into the while loop's body, or if the loop body is skipped and the sequence continues with the instructions that follow the loop.
You then want to make sure that something in the loop will change the condition so that there is a definite end to the loop. This could be reading a value from the user, or re-checking which events have occurred.

:::caution
At some point you will end up with an unexpected infinite loop. In these cases, you need to remember the details on how to [signal](../../../../part-0-getting-started/2-computer-use/1-concepts/10-signals) the operating system. You can use the ctrl-c to [kill](../../../../part-0-getting-started/2-computer-use/1-concepts/10-signals#killing-a-program-ctrl-c) the program.
:::

At a lower level, the while loop is achieved using two jump statements:

1. At the start of the loop, we have a conditional jump. If the condition is false, we jump to the instruction that follows the loop. Otherwise, control continues to flow in sequence to the loop's body (the statement following the condition).
2. At the end of the body of the loop, a jump statement is added to go back to the condition, and step 1 is repeated.

It is important to remember these actions that are performed. The while is just testing at the start, then either going into the body of the loop or jumping to the statement that follows. The value the condition evaluates to may change at any time, but it will only be checked when control is back at the top of the loop and the computer needs to determine whether to run the loop again or not.

:::tip
Remember everything is always in sequence. The word "while" seems to indicate that the code in the loop's body will only keep executing when the condition is true. If this were the case, our programs would suddenly be a lot more complex. For example, what happens if we are halfway through the body of a loop and the condition is suddenly false? Fortunately for us, this isn't how it works, so we don't need to worry. The condition is only checked when it is the instruction that is being run. So, you can retain the sequential, stepwise, thinking process as you picture how a loop works.
:::

## In C#

:::tip[Syntax]
The following diagram shows the C# syntax for a while loop.

![While loop syntax.](./images/while-loop.png)
:::

In C# the while loop starts with the `while` keyword followed by the condition within parenthesis. The statement to be repeated follows this, which in almost all cases will be a [compound statement](../02-0-compound-statement).

## How does `while` work?

Let's work through two examples: a while loop for a terminal-based program and one for a graphical application using SplashKit.

### Counting with `while`

The following code provides a simple example of how to work with a while loop. In this program we want to output a count from 0 up to a target the user provides. To achieve this, we will need a variable for the target which will store the value the user enters. We will also need a variable to keep track of our count, indicating which value we are up to.

These steps are coded into the program below.
The user is asked to enter a number, which we store in the `target` variable, and we create a second variable (`i`) that we use to count the number of times the loop runs. Before the loop, `i` is set to 0 as we generally count from 0 in our code.

The while loop runs **while** `i` is less than the `target`. Within the loop, we use the `i++` [assignment statement](../../../1-sequence-and-data/1-concepts/08-assignment-statement) to increase the value of `i`. This means that the value of `i` will eventually be larger than or equal to the `target`, thereby ensuring the loop will end.

```csharp
using static System.Console;
using static System.Convert;

int target;

Write("Count to: ");
target = ToInt32(ReadLine());

int i =  0;

while (i < target)
{
    WriteLine(i);
    i++;
}
```

:::tip[Why i?]
You will very often need to create working variables, like `i`, to help keep track of things for you. In this case, `i` is keeping track of the number of times the loop is run. When we have a simple integer value to track a count of something, we generally call this `i`. It comes from Fortran, an early language, where integer variables started with `i`. Developers then generally just used `i` if the variable had a simple counting purpose - it saved time thinking about what to call the variable and was easy to type. It stuck, and is now a common practice.
:::

Use the following images to see how this runs.

<MySwiper client:only height="" images={sliderImagesWhileLoop}></MySwiper>

### Event Loops - Dynamic graphical programs

Now let's look at how we can use a while loop to keep a window open in SplashKit. In this case, we can use the `QuitRequested` method from SplashKit to find out if the user has asked to quit the program by closing the SplashKit window on their screen. `QuitRequested` will return `false` if the user has not asked to quit, so we need to loop **while** quit is **not** requested. Remember, in C# we use `!` for "not", giving us a condition `!QuitRequested()` for our loop.

Within the loop, we need to tell SplashKit to respond to any events the user has performed. This is achieved with the `ProcessEvents()` method. It reads things like key presses, mouse movements, and window closes, and retains this information so that you can access it using other methods. In this case, it will record if the user has asked to quit, and we're accessing this information when we call `QuitRequested` in the condition. If you forget to add the call to `ProcessEvents` then you will not be able to close the window. In these cases, switch to the terminal and kill the program with [ctrl-c](../../../../part-0-getting-started/2-computer-use/1-concepts/10-signals).

```csharp
using static SplashKitSDK.SplashKit;

OpenWindow("Circle Test", 400, 400);
ClearScreen(ColorWhite());

while (!QuitRequested())
{
    FillCircle(RandomColor(), Rnd(ScreenWidth()), Rnd(ScreenHeight()), Rnd(50));
    RefreshScreen();

    ProcessEvents();
}
```

Use the following images to see how this runs.

<MySwiper client:only height="" images={sliderImagesWhileSplashKitLoop}></MySwiper>

If you have looked at sample code for most windowed programs online, you will not have seen this loop. This is what is generally known as an **event loop**, which the libraries usually take care of for you. That is great for productivity, but not great when you are trying to learn how this all works. With SplashKit we want you to be in control, so you need to create something like this loop to keep things going. When you move on to professional libraries, you will then have a good idea of what they are doing for you in the background.
